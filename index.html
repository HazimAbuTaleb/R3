<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Open Pit and Waste Dumps Closure ‚Äî v3 (TSR, Import/Export, PDF)</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body { margin: 0; font-family: 'Kommon Grotesk', Arial, sans-serif; background: #fff; color: #000; }

    /* Top banner */
    .top-banner { display:flex; justify-content:space-between; align-items:center; padding:10px 20px; margin:0 5%; border-bottom:1px solid #ddd; }
    .logo { display:flex; align-items:center; }
    .logo .lop { color:#CA1416; font-size:42px; font-weight:700; font-family: Arial, Helvetica, sans-serif; margin-right:10px; }
    .logo .project-text { color:grey; font-size:16px; font-weight:700; line-height:1.2; font-family:'Arazati Clara Condensada', 'Arial Narrow', sans-serif; }
    .top-banner nav a { margin-left:20px; text-decoration:none; color:#000; font-size:14px; }
    .top-banner nav a:hover { text-decoration:underline; }

    /* Second banner */
    .second-banner { background:#999; color:#fff; padding:10px; font-weight:700; }
    .second-banner h1.text { margin:0 0 0 20%; font-size:22px; }
    .second-banner .subtext { margin-left:20%; font-size:16px; font-weight:400; margin-top:5px; }

    /* Main body */
    .main-body { padding:20px; display:flex; flex-direction:column; gap:16px; }

    /* Controls */
    .left-panel { width:100%; border:1px solid #ccc; border-radius:8px; background:#fafafa; padding:12px 14px; }
    .left-panel .lp-banner { display:flex; justify-content:space-between; align-items:center; background:#efefef; border:1px solid #ddd; border-radius:6px; padding:8px 10px; font-weight:700; margin-bottom:12px; }
    #status { font-weight:600; font-size:12px; color:#2a6f2a; }
    #status.bad { color:#CA1416; }
    .controls { display:flex; align-items:center; gap:16px 24px; flex-wrap:wrap; }
    .control-group { display:grid; grid-template-columns:repeat(4, minmax(160px, 1fr)); gap:16px 24px; flex:1 1 auto; }
    .control { display:grid; gap:6px; }
    .control label { font-weight:600; font-size:14px; }

    /* Sliders */
    input[type="range"]{ width:100%; height:6px; background:#CA1416; border-radius:999px; outline:none; accent-color:#CA1416; }
    input[type="range"]::-webkit-slider-thumb{ width:16px; height:16px; border-radius:50%; background:#CA1416; border:2px solid #fff; box-shadow:0 0 0 1px #000; }
    input[type="range"]::-moz-range-track{ background:#CA1416; height:6px; border-radius:999px; }
    input[type="range"]::-moz-range-thumb{ width:16px; height:16px; border-radius:50%; background:#CA1416; border:2px solid #fff; box-shadow:0 0 0 1px #CA1416; }

    /* Toggles & actions */
    .actions { display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    .toggle { display:inline-flex; align-items:center; gap:10px; }
    .toggle input { appearance:none; width:40px; height:22px; background:#ddd; border-radius:999px; position:relative; outline:none; cursor:pointer; }
    .toggle input::after { content:""; position:absolute; top:2px; left:2px; width:18px; height:18px; border-radius:50%; background:#fff; transition:transform .2s ease; }
    .toggle input:checked { background:#CA1416; }
    .toggle input:checked::after { transform:translateX(18px); }

    .btn { appearance:none; border:1px solid #bbb; background:#fff; padding:8px 10px; border-radius:8px; cursor:pointer; font-weight:600; }
    .btn:hover { background:#f5f5f5; }

    /* Main grid (plots + table) */
    .main-grid { width:100%; display:grid; gap:16px; grid-template-columns:minmax(0,1fr) minmax(0,1fr) 600px; }
    .main-grid.two-panels { grid-template-columns:minmax(0,1fr) 600px; }
    .main-grid.two-panels #panel-2 { display:none; }
    .vpanel { border:1px solid #ccc; border-radius:8px; background:#fafafa; min-height:655px; overflow:hidden; display:flex; flex-direction:column; }
    .plot-title { padding:8px 10px; font-weight:700; border-bottom:1px solid #ddd; background:#efefef; display:flex; justify-content:space-between; align-items:center; }
    .plot { position:relative; width:100%; height:100%; min-height:640px; }

    /* Tables (bottom reference) */
    .tables-panel { width:100%; max-width:1300px; margin:0 auto; border:1px solid #ccc; border-radius:8px; background:#fafafa; padding:10px; display:grid; gap:20px; grid-template-columns:repeat(2, minmax(0,1fr)); align-items:start; }

    /* Input table */
    table { border-collapse:collapse; width:100%; }
    th, td { border:1px solid #ccc; padding:5px; text-align:center; font-weight:700; }
    .rows-ctl{ display:inline-flex; gap:8px; align-items:center; font-weight:600; }
    .id-input{ width:4.2em; text-transform:uppercase; }
    .select-cell, .select-header{ width:48px; text-align:center; }

    /* Instructions panel */
    .instructions-panel .instructions-body { font-weight:500; line-height:1.4; }
    .instructions-panel .instructions-body p { margin: 0 0 10px; }
    .instructions-panel .instructions-body ul,
    .instructions-panel .instructions-body ol { margin: 0 0 0 18px; padding: 0; }

    /* Color classes (match bottom reference) */
    .palered { background:#FFCCCC; }
    .red { background:#FF7C80; }
    .darkred { background:#FF0000; color:#fff; }
    .orange { background:#FFE699; }
    .yellow { background:#FFFF00; }
    .green { background:#C5E0B4; }
    .darkgreen { background:#00B050; color:#fff; }
    .blue { background:#00B0F0; color:#fff; }
    .purple { background:#7030A0; color:#fff; }

    /* Hide Target Assessment columns when comparative toggle is off */
    #inputTable.hide-target thead tr:nth-child(2) th.init-group { display:table-cell; }
    #inputTable.hide-target thead tr:first-child th:last-child { display:none; }
    #inputTable.hide-target thead tr:nth-child(2) th.tgt-group { display:none; }
    #inputTable.hide-target tbody td.tgt-group { display:none; }

    /* Hide TSR FoS columns when TSR toggle is off */
    #inputTable.hide-tsr thead tr:nth-child(2) th.col-tsr { display:none; }
    #inputTable.hide-tsr tbody td.col-tsr { display:none; }

    /* Responsive */
    @media (max-width: 1200px){
      .control-group { grid-template-columns:repeat(2, minmax(0,1fr)); }
      .plot { min-height:420px; }
      .main-grid, .main-grid.two-panels { grid-template-columns:1fr; }
      .tables-panel {grid-template-columns:1fr; }
      #panel-2 { display:block; }
    }
  </style>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <!-- For PDF export -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <div class="top-banner">
    <div class="logo">
      <div class="lop">LOP</div>
      <div class="project-text">Large Open Pit<br />Project</div>
    </div>
    <nav>
      <a href="#">Home</a><a href="#">About</a><a href="#">Sponsors</a><a href="#">Guidelines</a><a href="#">Webinars</a><a href="#">Projects</a><a href="#">News</a><a href="#">Contact us</a>
      <span class="search-icon">üîç</span>
    </nav>
  </div>

  <div class="second-banner">
    <h1 class="text">Open Pit and Waste Dumps Closure</h1>
    <div class="subtext">Target Risk Rating (R3)</div>
  </div>

  <div class="main-body">
    <!-- Controls -->
    <div class="left-panel">
      <div class="lp-banner">Controls <span id="status"></span></div>
      <div class="controls">
        <div class="control-group">
          <div class="control"><label for="azimRange">Rotation</label><input id="azimRange" type="range" min="-90" max="0" step="1" value="-30" /></div>
          <div class="control"><label for="elevRange">Tilt</label><input id="elevRange" type="range" min="1" max="89" step="1" value="15" /></div>
          <div class="control"><label for="zoomRange">Zoom</label><input id="zoomRange" type="range" min="-1" max="1" step="0.1" value="0" /></div>
          <div class="control"><label for="panZRange">Pan Vertical</label><input id="panZRange" type="range" min="-0.2" max="0.2" step="0.01" value="0" /></div>
        </div>
        <div class="actions">
          <label class="toggle"><input type="checkbox" id="toggleSpheres" /> <span>Render points as spheres</span></label>
          <label class="toggle"><input type="checkbox" id="comparative" /> <span>Comparative Assessment</span></label>
          <label class="toggle"><input type="checkbox" id="toggleTSR" checked /> <span>Show TSR FoS</span></label>
          <button class="btn" id="btnImportCSV" title="Import table data from CSV">Import Data</button>
          <button class="btn" id="btnExportCSV" title="Export table data as CSV">Export Data</button>
          <button class="btn" id="btnExportPDF" title="Export main grid and bottom tables as PDF">Export PDF</button>
          <input type="file" id="fileInput" accept=".csv,text/csv" hidden />
        </div>
      </div>
    </div>

    <!-- Plots + Input Table -->
    <div class="main-grid two-panels" id="mainGrid">
      <div class="vpanel" id="panel-1"><div class="plot-title">Initial Assessment</div><div id="plot1" class="plot"></div></div>
      <div class="vpanel" id="panel-2"><div class="plot-title">Target Assessment</div><div id="plot2" class="plot"></div></div>
      <div class="vpanel" id="panel-3">
        <div class="plot-title">
          <span>Input Table</span>
          <span class="rows-ctl">
            <label for="manualCount">Rows:</label>
            <select id="manualCount"></select>
          </span>
        </div>
        <table id="inputTable">
          <thead>
            <tr>
              <th rowspan="2" class="select-header"><input id="checkAll" type="checkbox" /></th>
              <th rowspan="2">ID</th>
              <th rowspan="2">SCR</th>
              <th colspan="4">Initial Assessment</th>
              <th colspan="4">Target Assessment</th>
            </tr>
            <tr>
              <th class="init-group">DCR</th><th class="init-group">FCR</th><th class="init-group">Score</th><th class="init-group col-tsr">TSR FoS</th>
              <th class="tgt-group">DCR</th><th class="tgt-group">FCR</th><th class="tgt-group">Score</th><th class="tgt-group col-tsr">TSR FoS</th>
            </tr>
          </thead>
          <tbody id="manualBody"></tbody>
        </table>
      </div>
    </div>

    <div class="left-panel instructions-panel">
      <div class="lp-banner">Instructions</div>
      <div class="instructions-body">
        <p>
          The relative risk rating (R<sup>3</sup>) index is calculated as outlined in Chapter 6 of the LOP Guideline for Open Pit and Waste Dump Closure:
          <b>R<sup>3</sup> = C<sub>f</sub> √ó C<sub>q</sub> √ó C<sub>l</sub></b>, where:
        </p>
        <ul>
          <li><b>C<sub>f</sub></b> ‚Äî design confidence rating (1‚Äì4)</li>
          <li><b>C<sub>q</sub></b> ‚Äî failure consequence rating (1‚Äì5)</li>
          <li><b>C<sub>l</sub></b> ‚Äî current slope class or required PMLU rating per the slope condition class or waste-dump/stockpile hazard classes (1‚Äì5)</li>
        </ul>
        <p></p>
        <p>
          Ranking for each rating is presented in the tables below. R<sup>3</sup> score classification and the suggested minimum target stability reliability (TSR) are also shown below.
        </p>
        <p><b>Steps to complete an R<sup>3</sup> assessment:</b></p>
        <ol>
          <li>Select the number of domains using the <b>Rows</b> dropdown at the top-right of the <b>Input Table</b> panel.</li>
          <li>Enter an ID/label for each domain (up to 4 characters).</li>
          <li>Select the <b>SCR</b> (Slope Condition Rating), <b>DCR</b> (Design Confidence Rating) and <b>FCR</b> (Failure Consequence Rating).</li>
          <li>R<sup>3</sup> score, suggested minimum <b>TSR FoS</b> and the plot(s) update automatically.</li>
          <li>Adjust the 3D plot view using the sliders in the <b>Controls</b> panel.</li>
          <li>To assess target post-closure rankings, enable <b>Comparative Assessment</b> to choose target <b>DCR</b> and <b>FCR</b>. A side-by-side comparison plot is created for initial vs target assessments.</li>
          <li>Hide the TSR columns in the table by turning off the <b>Show TSR FoS</b> toggle.</li>
          <li>Enter data via dropdowns, or import pre-populated values from CSV with <b>Import Data</b>. Create a template CSV with <b>Export Data</b>.</li>
          <li>Export plots and tables to PDF with <b>Export PDF</b>.</li>
        </ol>
      </div>
    </div>


    <!-- Bottom reference tables -->
    <div class="tables-panel" id="tablesPanel">
      <table>
        <tr><th>Slope Condition Class Rating</th><th>Design Confidence Rating</th><th>Failure Consequence Rating</th></tr>
        <tr><td class="red">V = 5</td><td class="red">VL = 4</td><td class="red">VH = 5</td></tr>
        <tr><td class="palered">IV = 4</td><td class="palered">L = 4</td><td class="palered">H = 4</td></tr>
        <tr><td class="orange">III = 3</td><td class="orange">M = 3</td><td class="orange">M = 3</td></tr>
        <tr><td class="yellow">II = 2</td><td class="yellow">H = 2</td><td class="yellow">L = 2</td></tr>
        <tr><td class="green">I = 1</td><td class="green">VH = 1</td><td class="green">VL = 1</td></tr>
      </table>
      <table>
        <tr><th rowspan="2">ESR R¬≥ Score</th><th colspan="2">Suggested TSR</th></tr>
        <tr><th>FoS</th><th>PoF</th></tr>
        <tr><td class="purple">80-100</td><td class="purple">&gt; 2.0</td><td class="purple">&lt; 0.5%</td></tr>
        <tr><td class="darkred">60-79</td><td class="darkred">&gt; 1.8</td><td class="darkred">&lt; 0.75%</td></tr>
        <tr><td class="yellow">30-59</td><td class="yellow">&gt; 1.5</td><td class="yellow">&lt; 1.0%</td></tr>
        <tr><td class="darkgreen">10-29</td><td class="darkgreen">&gt; 1.3</td><td class="darkgreen">&lt; 1.5%</td></tr>
        <tr><td class="blue">&lt;10</td><td class="blue">&gt; 1.2</td><td class="blue">&lt; 3%</td></tr>
      </table>
    </div>
  </div>


  <script>
    const statusEl = document.getElementById('status');
    function status(msg, bad){ if(!statusEl) return; statusEl.textContent = msg; statusEl.classList.toggle('bad', !!bad); (console[bad?'error':'log']||console.log)('[status]', msg); }

    window.addEventListener('DOMContentLoaded', ()=>{
      if(!window.Plotly){ status('Plotly failed to load (likely blocked by network/CDN).', true); document.getElementById('plot1').textContent='Plotly failed to load.'; document.getElementById('plot2').textContent='Plotly failed to load.'; }

      const plotDivs = [document.getElementById('plot1'), document.getElementById('plot2')];
      const manualCount = document.getElementById('manualCount');
      const manualBody = document.getElementById('manualBody');
      const inputTable = document.getElementById('inputTable');
      const mainGrid = document.getElementById('mainGrid');
      const tablesPanel = document.getElementById('tablesPanel');
      const comparativeToggle = document.getElementById('comparative');
      const toggleTSR = document.getElementById('toggleTSR');

      // block mouse interactions on plots (use sliders)
      plotDivs.forEach(pd=>{ const blocker=document.createElement('div'); blocker.style.position='absolute'; blocker.style.inset='0'; blocker.style.zIndex='10'; blocker.style.pointerEvents='auto'; blocker.title='Mouse disabled; use the sliders to spin/tilt/zoom'; pd.appendChild(blocker); });

      // Camera controls
      const azimRange=document.getElementById('azimRange');
      const elevRange=document.getElementById('elevRange');
      const zoomRange=document.getElementById('zoomRange');
      const panZRange=document.getElementById('panZRange');

      azimRange.value='-30'; elevRange.value='15'; zoomRange.value='0'; panZRange.value='0';

      function sphericalToEye(azimDeg,elevDeg,r){ const th=azimDeg*Math.PI/180, ph=elevDeg*Math.PI/180; return {x:r*Math.cos(ph)*Math.cos(th), y:r*Math.cos(ph)*Math.sin(th), z:r*Math.sin(ph)}; }
      function getCamera(){ const az=-Number(azimRange.value), el=Number(elevRange.value), r=1.6-Number(zoomRange.value); return { eye:sphericalToEye(az,el,r), up:{x:0,y:0,z:1}, center:{x:0,y:0,z:-0.1-Number(panZRange.value)} } }
      function applyCamera(){ if(window.Plotly){ plotDivs.forEach(pd=> Plotly.relayout(pd, {'scene.camera': getCamera()})); } }
      ;[azimRange,elevRange,zoomRange,panZRange].forEach(el=> el.addEventListener('input', applyCamera));

      const PLOT_CONFIG={ responsive:true, displaylogo:false, scrollZoom:false, doubleClick:false };
      function baseLayout(camera){
        return {
          showlegend:false,
          scene:{
            xaxis:{ title:{text:''}, range:[6.5,-2], visible:false, showgrid:false, ticks:'outside', showticklabels:false, tick0:0, dtick:1, ticklen:6, tickwidth:1, tickcolor:'#666' },
            yaxis:{ title:{text:''}, range:[6.5,-2], visible:false, showgrid:false, ticks:'outside', showticklabels:false, tick0:0, dtick:1, ticklen:6, tickwidth:1, tickcolor:'#666' },
            zaxis:{ title:{text:''}, range:[6.5,-2], visible:false, showgrid:false, ticks:'outside', showticklabels:false, tick0:0, dtick:1, ticklen:6, tickwidth:1, tickcolor:'#666' },
            aspectmode:'cube', showaxeslabels:false, bgcolor:'#ffffff', domain:{x:[0,1], y:[0,1]}, camera: camera
          },
          paper_bgcolor:'#ffffff',
          margin:{l:0,r:0,t:0,b:0,pad:0}
        };
      }

      // Bands / grids / labels (unchanged from v2)
      const GRID_COLOR='rgba(0,0,0,0.6)';
      function buildXYBands(){ const bands=[], x0=0,x1=5,z0=5, specs=[[0,1,'green',0.35],[1,2,'yellow',0.35],[2,3,'orange',0.35],[3,4,'red',0.35],[4,5,'red',0.45]]; for(const [y0,y1,color,op] of specs){ const x=[[x0,x1],[x0,x1]], y=[[y0,y0],[y1,y1]], z=[[z0,z0],[z0,z0]]; bands.push({type:'surface',x,y,z,showscale:false,opacity:op,colorscale:[[0,color],[1,color]],hoverinfo:'skip'});} return bands; }
      function buildXZBands(){ const bands=[], y0=5, specs=[[0,1,'green',0.35],[1,2,'yellow',0.35],[2,3,'orange',0.35],[3,4,'red',0.35],[4,5,'red',0.45]]; for(const [x0,x1,color,op] of specs){ const x=[[x0,x1],[x0,x1]], y=[[y0,y0],[y0,y0]], z=[[0,0],[5,5]]; bands.push({type:'surface',x,y,z,showscale:false,opacity:op,colorscale:[[0,color],[1,color]],hoverinfo:'skip'});} return bands; }
      function buildYZBands(){ const bands=[], y0=0,y1=5,x0=5, specs=[[0,1,'green',0.35],[1,2,'yellow',0.35],[2,3,'orange',0.35],[3,4,'red',0.35],[4,5,'red',0.45]]; for(const [z0,z1,color,op] of specs){ const x=[[x0,x0],[x0,x0]], y=[[y0,y0],[y1,y1]], z=[[z0,z1],[z0,z1]]; bands.push({type:'surface',x,y,z,showscale:false,opacity:op,colorscale:[[0,color],[1,color]],hoverinfo:'skip'});} return bands; }
      function buildXYGrid(){ const lines=[]; for(let v=0;v<=5;v++){ lines.push({type:'scatter3d',mode:'lines',x:[v,v],y:[0,5],z:[5,5],line:{width:1,color:GRID_COLOR},hoverinfo:'skip',showlegend:false}); lines.push({type:'scatter3d',mode:'lines',x:[0,5],y:[v,v],z:[5,5],line:{width:1,color:GRID_COLOR},hoverinfo:'skip',showlegend:false}); } return lines; }
      function buildXZGrid(){ const lines=[], y=5; for(let v=0;v<=5;v++){ lines.push({type:'scatter3d',mode:'lines',x:[v,v],y:[y,y],z:[0,5],line:{width:1,color:GRID_COLOR},hoverinfo:'skip',showlegend:false}); lines.push({type:'scatter3d',mode:'lines',x:[0,5],y:[y,y],z:[v,v],line:{width:1,color:GRID_COLOR},hoverinfo:'skip',showlegend:false}); } return lines; }
      function buildYZGrid(){ const lines=[], x=5; for(let v=0;v<=5;v++){ lines.push({type:'scatter3d',mode:'lines',x:[x,x],y:[v,v],z:[0,5],line:{width:1,color:GRID_COLOR},hoverinfo:'skip',showlegend:false}); lines.push({type:'scatter3d',mode:'lines',x:[x,x],y:[0,5],z:[v,v],line:{width:1,color:GRID_COLOR},hoverinfo:'skip',showlegend:false}); } return lines; }
      function buildExtraText(){
        const pts=[
          [0.5,5.1,0,'VH'],
          [1.5,5.1,0,'H'],
          [2.5,5.1,0,'M'],
          [3.5,5.1,0,'L'],
          [4.5,5.1,0,'VL'],
          [2.25,5.75,-0.5,'Design\nConfidence'],
          
          [5,-0.5,0.75,'VL'],
          [5,-0.5,1.75,'L'],
          [5,-0.5,2.75,'M'],
          [5,-0.5,3.75,'H'],
          [5,-0.5,4.75,'VH'],
          [5.75,0.5,0.1,'Failure\nConsequence'],
          
          [-0.5,0.5,5.25,'I'],
          [-0.5,1.5,5.25,'II'],
          [-0.5,2.5,5.25,'III'],
          [-0.5,3.5,5.25,'IV'],
          [-0.5,4.5,5.25,'V'],
          [-1.75,2.5,5.55,'Slope\nCondition\nClass']];

        const texts=pts.map(p=>String(p[3]));
        const sizes=texts.map(t=> (t.replace(/<br>/g,'\n').length>3?14:12));
        return {type:'scatter3d',mode:'text',x:pts.map(p=>p[0]),y:pts.map(p=>p[1]),z:pts.map(p=>p[2]),text:pts.map(p=>'<b>'+String(p[3]).replace(/\n/g,'<br>')+'</b>'),textfont:{size:sizes,color:'#000'},hoverinfo:'skip',showlegend:false};
      }

      // Scoring and mapping
      const SCR_ORDER=['I','II','III','IV','V'];
      const DCR_ORDER=['VL','VL-L','L','L-M','M','M-H','H','H-VH','VH'];
      const FCR_ORDER=['VL','L','M','H','VH'];
      const DCR_SCORE_MAP={VL:4,'VL-L':4,L:4,'L-M':3.5,M:3,'M-H':2.5,H:2,'H-VH':1.5,VH:1};
      const DCR_PLOT={VL:4.5,'VL-L':4,L:3.5,'L-M':3,M:2.5,'M-H':2,H:1.5,'H-VH':1,VH:0.5};
      const DCR_PLOT_INV=new Map(Object.entries(DCR_PLOT).map(([k,v])=>[v,k]));
      const FCR_SCORE_MAP={VL:1,L:2,M:3,H:4,VH:5};
      const norm=s=>String(s||'').trim().toUpperCase();
      const clampIdx=i=> (i<0?0:(i>4?4:i));
      const scrScore=s=>{ const i=SCR_ORDER.indexOf(norm(s)); return i<0?null:(i+1); }
      const dcrScore=s=> DCR_SCORE_MAP[norm(s)] ?? null;
      const fcrScore=s=> FCR_SCORE_MAP[norm(s)] ?? null;
      const scrPlot=s=>{ const i=SCR_ORDER.indexOf(norm(s)); return i<0?null:(i+0.5); }
      const dcrPlot=s=> DCR_PLOT[norm(s)] ?? null;
      const fcrPlot=s=>{ const i=FCR_ORDER.indexOf(norm(s)); return i<0?null:(i+0.5); }
      const xToSCR=x=> SCR_ORDER[clampIdx(Math.round(Number(x)-0.5))];
      const yToDCR=y=>{ const v=Number(y); if(!isFinite(v)) return 'VL'; return DCR_PLOT_INV.get(v) ?? 'VL'; }
      const zToFCR=z=> FCR_ORDER[clampIdx(Math.round(Number(z)-0.5))];

      // TSR FoS mapping from Score
      function scoreToTSRFoS(s){ const v=Number(s); if(!Number.isFinite(v)) return ''; if(v < 10) return '>1.2'; if(v <= 29) return '>1.3'; if(v <= 59) return '>1.5'; if(v <= 79) return '>1.8'; return '>2.0'; }

      // ID helpers
      function indexToLetters(i){ let n = i + 1, s = ''; while(n > 0){ const rem = (n - 1) % 26; s = String.fromCharCode(65 + rem) + s; n = Math.floor((n - 1) / 26); } return s; }

      // Conditional formatting helpers
      const COLOR_CLASSES=['palered','red','darkred','orange','yellow','green','darkgreen','blue','purple'];
      function tdSetColor(td, cls){ if(!td) return; COLOR_CLASSES.forEach(c=> td.classList.remove(c)); if(cls) td.classList.add(cls); }
      function scrToClass(v){ const m={I:'green',II:'yellow',III:'orange',IV:'palered',V:'red'}; return m[norm(v)]||''; }
      function dcrToClass(v){ const m={'VH':'green','H-VH':'green','H':'yellow','M-H':'yellow','M':'orange','L-M':'orange','L':'palered','VL-L':'palered','VL':'red'}; return m[norm(v)]||''; }
      function fcrToClass(v){ const m={VL:'green',L:'yellow',M:'orange',H:'palered',VH:'red'}; return m[norm(v)]||''; }
      function scoreClassFromVal(s){ const v=Number(s); if(!Number.isFinite(v)) return ''; if(v<10) return 'blue'; if(v<30) return 'darkgreen'; if(v<60) return 'yellow'; if(v<80) return 'darkred'; return 'purple'; }

      // Build table rows
      function updateRowScores(tr){
        const scr=tr.querySelector('.sel-scr')?.value;
        const dcr=tr.querySelector('.sel-dcr')?.value;
        const fcr=tr.querySelector('.sel-fcr')?.value;
        const tdcr=tr.querySelector('.sel-tdcr')?.value;
        const tfcr=tr.querySelector('.sel-tfcr')?.value;
        const sc1=(scr&&dcr&&fcr)? scrScore(scr)*dcrScore(dcr)*fcrScore(fcr) : '';
        const sc2=(scr&&tdcr&&tfcr)? scrScore(scr)*dcrScore(tdcr)*fcrScore(tfcr) : '';

        const sc1El=tr.querySelector('.score-initial'); if(sc1El) sc1El.textContent=String(sc1);
        const sc2El=tr.querySelector('.score-target'); if(sc2El) sc2El.textContent=String(sc2);

        const tsr1El=tr.querySelector('.tsr-initial'); if(tsr1El) tsr1El.textContent=scoreToTSRFoS(sc1);
        const tsr2El=tr.querySelector('.tsr-target'); if(tsr2El) tsr2El.textContent=scoreToTSRFoS(sc2);

        tdSetColor(tr.querySelector('.td-scr'), scrToClass(scr));
        tdSetColor(tr.querySelector('.td-dcr'), dcrToClass(dcr));
        tdSetColor(tr.querySelector('.td-fcr'), fcrToClass(fcr));
        tdSetColor(tr.querySelector('.td-score'), scoreClassFromVal(sc1));
        tdSetColor(tr.querySelector('.td-tsr'), scoreClassFromVal(sc1));
        tdSetColor(tr.querySelector('.td-tdcr'), dcrToClass(tdcr));
        tdSetColor(tr.querySelector('.td-tfcr'), fcrToClass(tfcr));
        tdSetColor(tr.querySelector('.td-tscore'), scoreClassFromVal(sc2));
        tdSetColor(tr.querySelector('.td-ttsr'), scoreClassFromVal(sc2));

      }

      function getManualRows(){
        const rows=[]; const trs=[...manualBody.querySelectorAll('tr')];
        trs.forEach(tr=>{
          const idInp = tr.querySelector('.row-id');
          const enableCb = tr.querySelector('.row-enable');
          const scrSel = tr.querySelector('.sel-scr');
          const dcrSel = tr.querySelector('.sel-dcr');
          const fcrSel = tr.querySelector('.sel-fcr');
          const tdcrSel = tr.querySelector('.sel-tdcr');
          const tfcrSel = tr.querySelector('.sel-tfcr');
          if(idInp && scrSel && dcrSel && fcrSel && tdcrSel && tfcrSel){
            rows.push({
              enabled: enableCb ? !!enableCb.checked : true,
              id: (idInp.value||'').toUpperCase().slice(0,4),
              scr: scrSel.value, dcr: dcrSel.value, fcr: fcrSel.value,
              tdcr: tdcrSel.value, tfcr: tfcrSel.value
            });
          }
        });
        return rows;
      }

      function manualRebuildRows(n, prev){
        const keep = Array.isArray(prev) ? prev : [];
        manualBody.innerHTML='';
        for(let i=0;i<n;i++){
          const data = keep[i] || {};
          const tr=document.createElement('tr');

          // Enable checkbox (first column)
          let td=document.createElement('td'); td.className='select-cell';
          const enCb=document.createElement('input'); enCb.type='checkbox'; enCb.className='row-enable'; enCb.checked = (data.enabled!==undefined)? !!data.enabled : true; td.appendChild(enCb); tr.appendChild(td);

          // ID (second column)
          td=document.createElement('td');
          const idInp=document.createElement('input'); idInp.type='text'; idInp.maxLength=4; idInp.className='id-input row-id'; idInp.value=(data.id)||indexToLetters(i); td.appendChild(idInp); tr.appendChild(td);

          const makeSel=(opts,val,cls)=>{ const s=document.createElement('select'); s.className=cls; opts.forEach(v=>{const o=document.createElement('option');o.value=v;o.textContent=v;s.appendChild(o);}); s.value = val || opts[0]; return s; };

          // Initial SCR/DCR/FCR/Score/TSR
          td=document.createElement('td'); td.className='td-scr'; const scrSel=makeSel(SCR_ORDER, data.scr||'I','sel-scr'); td.appendChild(scrSel); tr.appendChild(td);
          td=document.createElement('td'); td.className='td-dcr'; const dcrSel=makeSel(DCR_ORDER, data.dcr||'VH','sel-dcr'); td.appendChild(dcrSel); tr.appendChild(td);
          td=document.createElement('td'); td.className='td-fcr'; const fcrSel=makeSel(FCR_ORDER, data.fcr||'VL','sel-fcr'); td.appendChild(fcrSel); tr.appendChild(td);
          td=document.createElement('td'); td.className='td-score'; const sc1=document.createElement('span'); sc1.className='score-initial'; td.appendChild(sc1); tr.appendChild(td);
          td=document.createElement('td'); td.className='col-tsr td-tsr'; const tsr1=document.createElement('span'); tsr1.className='tsr-initial'; td.appendChild(tsr1); tr.appendChild(td);

          // Target DCR/FCR/Score/TSR (SCR shared)
          td=document.createElement('td'); td.className='td-tdcr tgt-group'; const tdcrSel=makeSel(DCR_ORDER, data.tdcr||dcrSel.value,'sel-tdcr'); td.appendChild(tdcrSel); tr.appendChild(td);
          td=document.createElement('td'); td.className='td-tfcr tgt-group'; const tfcrSel=makeSel(FCR_ORDER, data.tfcr||fcrSel.value,'sel-tfcr'); td.appendChild(tfcrSel); tr.appendChild(td);
          td=document.createElement('td'); td.className='td-tscore tgt-group'; const sc2=document.createElement('span'); sc2.className='score-target'; td.appendChild(sc2); tr.appendChild(td);
          td=document.createElement('td'); td.className='col-tsr tgt-group td-ttsr'; const tsr2=document.createElement('span'); tsr2.className='tsr-target'; td.appendChild(tsr2); tr.appendChild(td);

          // Events -> update + re-render
          [scrSel,dcrSel,fcrSel,tdcrSel,tfcrSel].forEach(el=> el.addEventListener('change', ()=>{ updateRowScores(tr); renderFromTable(); }));
          ;[idInp,enCb].forEach(el=> el.addEventListener('input', ()=>{ renderFromTable(); }));

          manualBody.appendChild(tr);
          updateRowScores(tr);
        }
        syncHeaderCheckbox();
      }

      // Select-all in header (checkbox)
      const checkAllEl = document.getElementById('checkAll');
      function setAllCheckboxes(state){ manualBody.querySelectorAll('.row-enable').forEach(cb => { cb.checked = state; }); renderFromTable(); }
      function syncHeaderCheckbox(){
        const boxes=[...manualBody.querySelectorAll('.row-enable')];
        const total=boxes.length; const checked=boxes.filter(cb=>cb.checked).length;
        checkAllEl.checked = total>0 && checked===total;
        checkAllEl.indeterminate = checked>0 && checked<total;
      }
      checkAllEl?.addEventListener('change', ()=>{ setAllCheckboxes(!!checkAllEl.checked); syncHeaderCheckbox(); });
      manualBody.addEventListener('change', (e)=>{ if(e.target && e.target.classList.contains('row-enable')) syncHeaderCheckbox(); });

      // Points + traces
      function scoreToColor(s){ if (s < 10) return 'blue'; if (s < 30) return 'green'; if (s < 60) return 'yellow'; if (s < 80) return 'red'; return 'purple'; }
      function scaleLinear(values){ const s_min=10, s_max=65; const mslope=(s_max - s_min)/99; const cint=s_min - mslope; return values.map(v => mslope*v + cint); }
      function buildProjections(xs,ys,zs){ const t=[], dash={width:1,color:'black',dash:'dot'}; {const x=[],y=[],z=[]; for(let i=0;i<xs.length;i++){ x.push(xs[i],xs[i],null); y.push(ys[i],ys[i],null); z.push(zs[i],5,null);} t.push({type:'scatter3d',mode:'lines',x,y,z,line:{...dash},hoverinfo:'skip',showlegend:false}); t.push({type:'scatter3d',mode:'markers',x:xs,y:ys,z:xs.map(()=>5),marker:{symbol:'x',size:1.5,color:'black'},hoverinfo:'skip',showlegend:false}); } {const x=[],y=[],z=[]; for(let i=0;i<xs.length;i++){ x.push(xs[i],xs[i],null); y.push(ys[i],5,null); z.push(zs[i],zs[i],null);} t.push({type:'scatter3d',mode:'lines',x,y,z,line:{...dash},hoverinfo:'skip',showlegend:false}); t.push({type:'scatter3d',mode:'markers',x:xs,y:xs.map(()=>5),z:zs,marker:{symbol:'x',size:1.5,color:'black'},hoverinfo:'skip',showlegend:false}); } {const x=[],y=[],z=[]; for(let i=0;i<xs.length;i++){ x.push(xs[i],5,null); y.push(ys[i],ys[i],null); z.push(zs[i],zs[i],null);} t.push({type:'scatter3d',mode:'lines',x,y,z,line:{...dash},hoverinfo:'skip',showlegend:false}); t.push({type:'scatter3d',mode:'markers',x:xs.map(()=>5),y:ys,z:zs,marker:{symbol:'x',size:1.5,color:'black'},hoverinfo:'skip',showlegend:false}); } return t; }
      function renameOverlapLabels(xs,ys,zs,labels){ const groups=new Map(); for(let i=0;i<xs.length;i++){ const key=`${xs[i]}|${ys[i]}|${zs[i]}`; const lbl=(labels[i]&&String(labels[i]).trim())?String(labels[i]).trim():indexToLetters(i); if(!groups.has(key)) groups.set(key, []); groups.get(key).push(lbl); } const combined=new Map(); groups.forEach((arr,key)=> combined.set(key, arr.join(', '))); return labels.map((_,i)=> combined.get(`${xs[i]}|${ys[i]}|${zs[i]}`)); }
      

      function makeTraces(points){
        const bg=[...buildXYBands(),...buildXZBands(),...buildYZBands(),
                  ...buildXYGrid(),...buildXZGrid(),...buildYZGrid(),
                  buildExtraText()];

        if(!Array.isArray(points) || !points.length){ return bg; }

        // coords & labels
        const xs = points.map(p=> +p.x);
        const ys = points.map(p=> +p.y);
        const zs = points.map(p=> +p.z);
        const labels = points.map(p=> p.label || '');
        const labelsRen = renameOverlapLabels(xs,ys,zs,labels);

        // score used by existing scaling/colouring (fallback logic preserved)
        const scores = points.map((p,i)=>
          (Number.isFinite(p.score) ? p.score :
            scrScore(p._scr ?? xToSCR(ys[i])) *
            dcrScore(p._dcr ?? yToDCR(xs[i])) *
            fcrScore(p._fcr ?? zToFCR(zs[i]))
          )
        );

        // PRESERVE your size scaling & colouring
        const sizesPx = points.map((p,i)=> Number.isFinite(p.sizePx) ? p.sizePx : scoreToSizePxLinear(scores[i], 1, 100, 10, 65));
        const colors  = points.map((p,i)=> p.color || scoreToColor(scores[i]));

        const traces=[...bg, ...buildProjections(xs,ys,zs)];

        const asSpheres = document.getElementById('toggleSpheres')?.checked;

        if (!asSpheres) {
          // Standard marker points (unchanged behaviour)
          traces.push({
            type:'scatter3d', mode:'markers',
            x:xs, y:ys, z:zs, text:labelsRen,
            marker:{ size:sizesPx, color:colors, line:{width:1.5, color:'#000'}, symbol:'circle' },
            customdata:scores,
            hovertemplate:'%{text}<br>x=%{x}<br>y=%{y}<br>z=%{z}<br>score=%{customdata}<extra></extra>'
          });
          // label halo + text
          traces.push({
            type:'scatter3d', mode:'text', x:xs, y:ys, z:zs,
            text:labelsRen.map(l=> l?('<b>'+l+'</b>'):''), textposition:'bottom center',
            textfont:{size:16, color:'#fff'}, hoverinfo:'skip', showlegend:false
          },{
            type:'scatter3d', mode:'text', x:xs, y:ys, z:zs,
            text:labelsRen.map(l=> l?('<b>'+l+'</b>'):''), textposition:'bottom center',
            textfont:{size:15, color:'#000'}, hoverinfo:'skip', showlegend:false
          });
        } else {
          // Sphere meshes: keep same colour & perceived size (convert px‚Üíradius)
          for (let i=0;i<xs.length;i++){
            const r = sizePxToRadius(sizesPx[i]);
            traces.push(sphereMesh(xs[i], ys[i], zs[i], r, 14, 14, colors[i]));
            if (labelsRen[i]) {
              traces.push({
                type:'scatter3d', mode:'text', x:xs, y:ys, z:zs,
                text:labelsRen.map(l=> l?('<b>'+l+'</b>'):''), textposition:'bottom center',
                textfont:{size:16, color:'#fff'}, hoverinfo:'skip', showlegend:false
              },{
                type:'scatter3d', mode:'text', x:xs, y:ys, z:zs,
                text:labelsRen.map(l=> l?('<b>'+l+'</b>'):''), textposition:'bottom center',
                textfont:{size:15, color:'#000'}, hoverinfo:'skip', showlegend:false
              });
            }
          }
        }

        return traces;
      }

      function render(initPts, tgtPts){ if(!window.Plotly) return; const layout=baseLayout(getCamera()); const cfg=PLOT_CONFIG; Plotly.newPlot(plotDivs[0], makeTraces(initPts||[]), layout, cfg); Plotly.newPlot(plotDivs[1], makeTraces(tgtPts||[]), layout, cfg); const total=(initPts&&initPts.length)||0; status(total?`Plotted ${total} point${total===1?'':'s'}.`:'No rows to plot.', !total); }

      // Build points from table rows
      function buildPointsFromRows(rows, target=false){ const pts=[]; rows.forEach((r,idx)=>{ if(!r.enabled) return; const scr=r.scr; const dcr=target? r.tdcr : r.dcr; const fcr=target? r.tfcr : r.fcr; const x=dcrPlot(dcr), y=scrPlot(scr), z=fcrPlot(fcr); if(x!=null&&y!=null&&z!=null){ pts.push({x,y,z,label:(r.id||indexToLetters(idx)), _scr:scr, _dcr:dcr, _fcr:fcr}); } }); return pts; }
      function gatherManualPointsInitial(){ return buildPointsFromRows(getManualRows(), false); }
      function gatherManualPointsTarget(){ return buildPointsFromRows(getManualRows(), true); }
      function renderFromTable(){ render(gatherManualPointsInitial(), gatherManualPointsTarget()); }

      // Rows dropdown (preserve values)
      for(let i=1;i<=20;i++){ const opt=document.createElement('option'); opt.value=String(i); opt.textContent=String(i); manualCount.appendChild(opt); }
      manualCount.value='5';
      manualRebuildRows(5);
      manualCount.addEventListener('change', ()=>{ const prev=getManualRows(); const n=parseInt(manualCount.value,10)||1; manualRebuildRows(n, prev); renderFromTable(); });

      // Toggles
      function resizePlots(){ if(window.Plotly){ plotDivs.forEach(pd=>{ try{ Plotly.Plots.resize(pd); }catch(e){} }); } }
      function applyComparative(){ const on=!!comparativeToggle.checked; inputTable.classList.toggle('hide-target', !on); mainGrid.classList.toggle('two-panels', !on); requestAnimationFrame(()=>{ resizePlots(); applyCamera(); }); }
      comparativeToggle.addEventListener('change', applyComparative);
      applyComparative(); // default off -> two panels

      function applyTSRToggle(){ inputTable.classList.toggle('hide-tsr', !toggleTSR.checked); }
      toggleTSR.addEventListener('change', applyTSRToggle);
      applyTSRToggle();

      function sphereMesh(cx, cy, cz, r, seg=12, rings=12, color='#1f77b4') {
        const xs=[], ys=[], zs=[], i=[], j=[], k=[];
        for (let a=0; a<=rings; a++) {
          const v=a*Math.PI/rings, sv=Math.sin(v), cv=Math.cos(v);
          for (let b=0; b<=seg; b++) {
            const u=b*2*Math.PI/seg;
            xs.push(cx + r*Math.cos(u)*sv);
            ys.push(cy + r*Math.sin(u)*sv);
            zs.push(cz + r*cv);
          }
        }
        const cols=seg+1;
        for (let a=0; a<rings; a++) {
          for (let b=0; b<seg; b++) {
            const p=a*cols+b, q=p+cols;
            // two triangles per quad
            i.push(p,   p+1);
            j.push(q,   q);
            k.push(p+1, q+1);
          }
        }
        return {
          type:'mesh3d', x:xs, y:ys, z:zs, i, j, k, color,
          opacity:0.5, showscale:false,
          lighting:{ambient:0.4, diffuse:0.8, specular:0.3, roughness:0.9},
          hoverinfo:'skip'
        };
      }
      // map marker pixel size ‚Üí approximate data-space radius (axes ~0‚Äì5)
      function scoreToSizePxLinear(s, domainMin=1, domainMax=100, pxMin=2, pxMax=90){
        const sNum = +s;
        const sClamped = Math.max(domainMin, Math.min(domainMax, Number.isFinite(sNum) ? sNum : domainMin));
        const t = (sClamped - domainMin) / (domainMax - domainMin); // 0..1
        return pxMin + t * (pxMax - pxMin);
      }
      
      function sizePxToRadius(px){
        const pxMin = 2, pxMax = 90;
        const t = Math.max(0, Math.min(1, (px - pxMin) / (pxMax - pxMin)));
        return 0.01 + 0.82 * t; // r_min=0.02 (tiny), r_max‚âà0.57 (big)
      }

      // re-render when toggled (uses your existing renderFromTable)
      document.getElementById('toggleSpheres')?.addEventListener('change', () => {
        if (typeof renderFromTable === 'function') renderFromTable();
      });


      // Initial render
      renderFromTable();
      window.addEventListener('resize', resizePlots);

      // ===== Import/Export (CSV) =====
      const btnExportCSV=document.getElementById('btnExportCSV');
      const btnImportCSV=document.getElementById('btnImportCSV');
      const fileInput=document.getElementById('fileInput');

      function toCSVValue(v){
        const s = String(v==null?'':v);
        if(/[",\n]/.test(s)){ return '"'+s.replace(/"/g,'""')+'"'; }
        return s;
      }
      function rowsToCSV(rows){
        const header = ['ID','SCR','DCR','FCR','Score', 'TSR FoS', 'T-DCR','T-FCR', 'T-Score', 'T-TSR FoS'];
        const lines = [header.join(',')];
        rows.forEach(r=>{
            const s1 = (r.scr && r.dcr && r.fcr) ? scrScore(r.scr)*dcrScore(r.dcr)*fcrScore(r.fcr) : '';
            const s2 = (r.scr && r.tdcr && r.tfcr) ? scrScore(r.scr)*dcrScore(r.tdcr)*fcrScore(r.tfcr) : '';
            const t1 = scoreToTSRFoS(s1);
            const t2 = scoreToTSRFoS(s2);
            lines.push([
                toCSVValue((r.id||'').toUpperCase()),
                toCSVValue(r.scr), toCSVValue(r.dcr), toCSVValue(r.fcr), toCSVValue(s1), toCSVValue(t1),
                toCSVValue(r.tdcr), toCSVValue(r.tfcr), toCSVValue(s2), toCSVValue(t2)
            ].join(','));
        });
        return lines.join('\n');
      }
      function exportTableDataCSV(){
        const csv = rowsToCSV(getManualRows());
        const blob = new Blob([csv], {type:'text/csv'});
        const url = URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url; a.download='R3_Input_Data.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1000);
      }

      function parseCSV(text) {
        const rows = [];
        let i = 0, cur = '', inq = false, row = [];
        const pushCell = () => { row.push(cur); cur = ''; };
        const pushRow = () => {
            if (cur !== '' || row.length) pushCell();
            if (row.some(c => c !== '')) rows.push(row);
            row = [];
        };

        while (i < text.length) {
            const ch = text[i++];

            if (inq) {
            if (ch === '"') {
                if (text[i] === '"') { cur += '"'; i++; } // escaped quote
                else { inq = false; }
            } else {
                cur += ch;
            }
            } else {
            if (ch === '"') inq = true;
            else if (ch === ',') pushCell();
            else if (ch === '\r' || ch === '\n') {        // handle CR, LF, CRLF
                if (ch === '\r' && text[i] === '\n') i++;   // skip the LF in CRLF
                pushRow();
            } else {
                cur += ch;
            }
            }
        }
        // flush last row
        if (cur !== '' || row.length) {
            pushCell();
            if (row.some(c => c !== '')) rows.push(row);
        }
        return rows;
        }

        function csvToRows(csv) {
        const arr = parseCSV(csv);
        if (!arr.length) throw new Error('Empty CSV');

        const header = arr[0].map(h => h.trim().toLowerCase());
        const idx = (name) => header.indexOf(name);

        const required = ['id','scr','dcr','fcr','t-dcr','t-fcr'];
        const missing = required.filter(n => idx(n) < 0);
        if (missing.length) {
            throw new Error('Missing required headers: ' + missing.join(', '));
        }

        const [iId, iScr, iDcr, iFcr, iTdcr, iTfcr] = required.map(idx);
        const iEnabled = idx('enabled'); // optional

        const cell = (r, i) => String((i >= 0 ? r[i] : '') ?? '').trim();

        return arr.slice(1)
            .map(r => ({
            id:   cell(r, iId).toUpperCase().slice(0, 4),
            scr:  cell(r, iScr).toUpperCase(),
            dcr:  cell(r, iDcr).toUpperCase(),
            fcr:  cell(r, iFcr).toUpperCase(),
            tdcr: cell(r, iTdcr).toUpperCase(),
            tfcr: cell(r, iTfcr).toUpperCase(),
            enabled: /^(1|true|yes|y)$/i.test(cell(r, iEnabled))
            }))
            .filter(o => o.id || o.scr || o.dcr || o.fcr || o.tdcr || o.tfcr);
        }

        function importTableDataCSV(text) {
        try {
            const rows = csvToRows(text);
            const n = Math.max(1, Math.min(20, rows.length || 1));
            manualCount.value = String(n);
            manualRebuildRows(n);

            const trs = [...manualBody.querySelectorAll('tr')];

            rows.slice(0, n).forEach((r, i) => {
            const tr = trs[i]; if (!tr) return;

            const setChecked = (sel, val) => {
                const el = tr.querySelector(sel);
                if (el) el.checked = !!val;
            };
            const setValueIf = (sel, val, validator = () => true) => {
                const el = tr.querySelector(sel);
                if (el && validator(val)) el.value = val;
            };

            setChecked('.row-enable', true);
            setValueIf('.row-id', (r.id || '').toUpperCase().slice(0, 4));

            setValueIf('.sel-scr',  r.scr,  v => SCR_ORDER.includes(v));
            setValueIf('.sel-dcr',  r.dcr,  v => DCR_ORDER.includes(v));
            setValueIf('.sel-fcr',  r.fcr,  v => FCR_ORDER.includes(v));
            setValueIf('.sel-tdcr', r.tdcr, v => DCR_ORDER.includes(v));
            setValueIf('.sel-tfcr', r.tfcr, v => FCR_ORDER.includes(v));

            updateRowScores(tr);
            });

            renderFromTable();
            status('Imported table data (CSV).');
        } catch (err) {
            const msg = 'Import failed: ' + (err?.message || String(err));
            status(msg, true);
            alert(msg);
        }
        }

      btnExportCSV.addEventListener('click', exportTableDataCSV);
      btnImportCSV.addEventListener('click', ()=> fileInput.click());
      fileInput.addEventListener('change', async (e)=>{
        const file=e.target.files && e.target.files[0]; if(!file) return;
        try{ const text=await file.text(); importTableDataCSV(text); }catch(err){ status('Import failed: '+err.message, true); alert('Import failed: '+err.message); }
        finally{ fileInput.value=''; }
      });























    // ===== Export PDF (banners + main grid + bottom tables on one A4 landscape page) =====
    const btnExportPDF = document.getElementById('btnExportPDF');

    function sizeOf(el){
    const r = el.getBoundingClientRect();
    return { w: Math.max(1, r.width), h: Math.max(1, r.height) };
    }

    function makeImg(dataUrl, w, h){
    const img = document.createElement('img');
    img.src = dataUrl;
    img.style.width = w + 'px';
    img.style.height = h + 'px';
    img.style.display = 'block';
    img.style.maxWidth = 'none';
    img.style.maxHeight = 'none';
    return img;
    }

    /** Swap common chart types for images; return a restore() fn. */
    async function swapChartsForImages(root){
    const swaps = [];

    // --- Plotly ---
    const plotlyNodes = Array.from(root.querySelectorAll('.js-plotly-plot'));
    for (const el of plotlyNodes) {
        try {
        if (!window.Plotly) continue;
        const { w, h } = sizeOf(el);
        const uri = await window.Plotly.toImage(el, { format: 'png', width: Math.round(w), height: Math.round(h), scale: 2 });
        const img = makeImg(uri, w, h);
        el.parentNode.replaceChild(img, el);
        swaps.push(()=>{ img.parentNode && img.parentNode.replaceChild(el, img); });
        } catch {}
    }

    // --- Chart.js (v3+) ---
    const canvases = Array.from(root.querySelectorAll('canvas'));
    for (const cv of canvases) {
        try {
        let chart = null;
        if (window.Chart && typeof window.Chart.getChart === 'function') {
            chart = window.Chart.getChart(cv);
        } else if (cv && cv._chart) {
            chart = cv._chart; // older fallback
        }
        if (!chart) continue;
        const { w, h } = sizeOf(cv);
        const uri = chart.toBase64Image('image/png', 1); // Chart.js built-in
        if (!uri) continue;
        const img = makeImg(uri, w, h);
        cv.parentNode.replaceChild(img, cv);
        swaps.push(()=>{ img.parentNode && img.parentNode.replaceChild(cv, img); });
        } catch {}
    }

    // --- ECharts ---
    const echartsRoots = Array.from(root.querySelectorAll('[data-echarts-root], .echarts, .echart'));
    for (const node of echartsRoots) {
        try {
        const inst = window.echarts && window.echarts.getInstanceByDom
            ? window.echarts.getInstanceByDom(node)
            : null;
        if (!inst) continue;
        const { w, h } = sizeOf(node);
        const uri = inst.getDataURL({ type:'png', pixelRatio:2, backgroundColor:'#fff' });
        const img = makeImg(uri, w, h);
        node.parentNode.replaceChild(img, node);
        swaps.push(()=>{ img.parentNode && img.parentNode.replaceChild(node, img); });
        } catch {}
    }

    // --- Highcharts ---
    const hcContainers = Array.from(root.querySelectorAll('.highcharts-container, .highcharts-root'));
    for (const container of hcContainers) {
        try {
        if (!window.Highcharts || !Array.isArray(window.Highcharts.charts)) continue;
        const chart = window.Highcharts.charts.find(c => c && (c.container === container || (c.renderTo && c.renderTo.contains(container))));
        if (!chart) continue;
        const base = chart.renderTo || container;
        const { w, h } = sizeOf(base);
        const svg = chart.getSVG();
        const uri = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
        const img = makeImg(uri, w, h);
        base.parentNode.replaceChild(img, base);
        const orig = base;
        swaps.push(()=>{ img.parentNode && img.parentNode.replaceChild(orig, img); });
        } catch {}
    }

    // return restore
    return () => { swaps.reverse().forEach(fn => { try { fn(); } catch {} }); };
    }

    // Clamp html2canvas size and prefer non-tainted path
    async function captureElement(el, requestedScale = 2, maxSidePx = 8000, useFO = false) {
    await document.fonts?.ready?.catch(()=>{});
    await new Promise(r => requestAnimationFrame(() => setTimeout(r, 80)));

    const rect = el.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    let scale = Math.min(requestedScale * dpr, maxSidePx / Math.max(rect.width, rect.height));
    scale = Math.max(1, Math.min(scale, 3));

    const canvas = await html2canvas(el, {
        scale,
        useCORS: true,
        allowTaint: false,
        foreignObjectRendering: useFO,
        backgroundColor: '#ffffff',
        imageTimeout: 0,
        logging: false
    });

    // retry with FO if looks blank
    const tiny = canvas.width < 10 || canvas.height < 10;
    let blank = false;
    try {
        const ctx = canvas.getContext('2d');
        const data = ctx.getImageData(0, 0, Math.min(10, canvas.width||1), Math.min(10, canvas.height||1)).data;
        blank = !data || data.every(v => v === 0);
    } catch { /* ignore */ }

    if (!useFO && (tiny || blank)) {
        return captureElement(el, requestedScale, maxSidePx, true);
    }
    return canvas.toDataURL('image/jpeg', 0.9);
    }

    const PX_PER_IN = 96;
    const MM_PER_IN = 25.4;
    const pxToMm = (px) => (px / PX_PER_IN) * MM_PER_IN;

    async function exportPDF(){
    try{
      const { jsPDF } = window.jspdf;
      const a4w = 297, a4h = 210; // landscape mm
      const margin = 6;
      const pageW = a4w - margin * 2;
      const pageH = a4h - margin * 2;

      // 10px gap between stacked panels (converted to mm)
      const gapPx = 10;
      const gapMmBase = pxToMm(gapPx);

      // Reduce Tables panel by 25%
      const tablesScaleRel = 0.75;

      const pdf = new jsPDF({ orientation:'landscape', unit:'mm', format:'a4' });

      // Select banners
      const logoEl    = document.querySelector('.logo');            // top banner 1 (fixed 70px height in PDF)
      const banner2El = document.querySelector('.second-banner');   // top banner 2

      // 1) Swap charts to images so plots render (content zones)
      const restoreMain   = await swapChartsForImages(mainGrid);
      const restoreTables = await swapChartsForImages(tablesPanel);

      // 2) Capture areas
      const [logoImg, banner2Img, mainGridImg, tablesImg] = await Promise.all([
        logoEl    ? captureElement(logoEl, 2, 8000)    : Promise.resolve(null),
        banner2El ? captureElement(banner2El, 2, 8000) : Promise.resolve(null),
        captureElement(mainGrid, 2, 8000),
        captureElement(tablesPanel, 2, 8000)
      ]);

      // 3) Restore DOM immediately
      restoreMain(); restoreTables();

      // 4) Compute sizes to fit ALL on one page
      const props = (img) => img ? pdf.getImageProperties(img) : null;
      const pLogo = props(logoImg);
      const pB2   = props(banner2Img);
      const p1    = pdf.getImageProperties(mainGridImg);
      const p2    = pdf.getImageProperties(tablesImg);

      // Scaling:
      let logoW0 = 0, logoH0 = 0;
      if (pLogo) {
        const targetLogoHpx = 35;
        logoH0 = pxToMm(targetLogoHpx);
        logoW0 = logoH0 * (pLogo.width / pLogo.height);
        if (logoW0 > pageW) { const k = pageW / logoW0; logoW0 *= k; logoH0 *= k; }
      }

      // - second banner uses full page width; height by aspect ratio
      let b2W0 = 0, b2H0 = 0;
      if (pB2) {
        b2W0 = pageW;
        b2H0 = b2W0 * (pB2.height / pB2.width);
      }

      // - main sections fill page width; heights by aspect ratio
      const w1_0 = pageW, h1_0 = w1_0 * (p1.height / p1.width);

      // tables panel at 75% relative size (both width and height)
      const w2_0_full = pageW, h2_0_full = w2_0_full * (p2.height / p2.width);
      const w2_0 = w2_0_full * tablesScaleRel;
      const h2_0 = h2_0_full * tablesScaleRel;

      // Gaps: between (logo‚Üíbanner2 if both exist) + (banner2‚Üímain if banner2 exists OR logo exists) + (main‚Üítables)
      const items = [pLogo ? 'logo' : null, pB2 ? 'b2' : null, 'main', 'tables'].filter(Boolean);
      const gapsCount = Math.max(0, items.length - 1);
      const gapsTotalMm = gapsCount * gapMmBase;

      // Total requested height (mm) before global scale
      const totalWanted =
        (pLogo ? logoH0 : 0) +
        (pB2 ? b2H0 : 0) +
        h1_0 + h2_0 +
        gapsTotalMm;

      // Uniform downscale if needed to fit pageH
      const scale = totalWanted > pageH ? (pageH / totalWanted) : 1;

      // Apply global scale
      const logoW = logoW0 * scale, logoH = logoH0 * scale;
      const b2W   = b2W0   * scale, b2H   = b2H0   * scale;
      const w1    = w1_0   * scale, h1    = h1_0   * scale;
      const w2    = w2_0   * scale, h2    = h2_0   * scale;
      const gap   = gapMmBase * scale;

      // 5) Draw centered horizontally, stacked from top margin with gaps
      let y = margin;

      if (pLogo) {
        const xLogo = margin; // left-aligned at content left
        pdf.addImage(logoImg, 'JPEG', xLogo, y, logoW, logoH);
        y += logoH + gap;
      }

      if (pB2) {
        const xB2 = (a4w - b2W) / 2;
        pdf.addImage(banner2Img, 'JPEG', xB2, y, b2W, b2H);
        y += b2H + gap;
      }

      const x1 = (a4w - w1) / 2;
      pdf.addImage(mainGridImg, 'JPEG', x1, y, w1, h1);
      y += h1 + gap;

      const x2 = margin;
      pdf.addImage(tablesImg, 'JPEG', x2, y, w2, h2);

      // 6) Save
      pdf.save('R3 Assessment.pdf');
      status('Exported PDF.');
    } catch (err) {
      const msg = 'PDF export failed: ' + (err?.message || String(err));
      status(msg, true);
      alert(msg);
    }
  }

    btnExportPDF.addEventListener('click', exportPDF);


    });
  </script>
</body>
</html>
